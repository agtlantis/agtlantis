import type { AgentPrompt, EvalAgent, TestCase } from '@/core/types'
import type { EvalReport } from '@/reporter/types'
import type { Judge } from '@/judge/types'
import type { Improver, Suggestion } from '@/improver/types'
import type { EvalPricingConfig } from '@/reporter/cost-helpers'
import type { ImprovementSession } from './history'

/** Terminate when average score reaches threshold */
export interface TargetScoreCondition {
  type: 'targetScore'
  /** Score threshold (0-100) */
  threshold: number
}

/** Terminate after N rounds */
export interface MaxRoundsCondition {
  type: 'maxRounds'
  /** Maximum number of improvement rounds */
  count: number
}

/** Terminate when score doesn't improve for N consecutive rounds */
export interface NoImprovementCondition {
  type: 'noImprovement'
  /** Number of consecutive rounds without improvement */
  consecutiveRounds: number
  /** Minimum score delta to count as improvement (default: 0) */
  minDelta?: number
}

/** Terminate when total cost exceeds budget */
export interface MaxCostCondition {
  type: 'maxCost'
  /** Maximum cost in USD */
  maxUSD: number
}

/** Custom condition with user-defined check function */
export interface CustomCycleCondition {
  type: 'custom'
  /** Function to check if termination condition is met */
  check: (ctx: CycleContext) => boolean | Promise<boolean>
  /** Human-readable description (for debugging/logging) */
  description?: string
}

/** Discriminated union of termination conditions. Uses OR semantics - first match triggers. */
export type CycleTerminationCondition =
  | TargetScoreCondition
  | MaxRoundsCondition
  | NoImprovementCondition
  | MaxCostCondition
  | CustomCycleCondition

/** Context available to termination condition checks */
export interface CycleContext {
  /** Current round number (1-indexed) */
  currentRound: number
  /** Average score from the latest round */
  latestScore: number
  /** Score history from all previous rounds */
  previousScores: number[]
  /** Total accumulated cost in USD */
  totalCost: number
  /** Full history of completed rounds */
  history: RoundResult[]
}

/** Result when cycle should continue (no termination) */
export interface CycleContinueResult {
  terminated: false
  reason: string
  /** Not present when not terminated (for type safety with discriminated union) */
  matchedCondition?: never
}

/** Result when cycle should terminate */
export interface CycleTerminatedResult {
  terminated: true
  matchedCondition: CycleTerminationCondition
  reason: string
}

export type CycleTerminationResult = CycleContinueResult | CycleTerminatedResult

/**
 * Data yielded after each improvement round for Human-in-the-Loop (HITL) control.
 * The AsyncGenerator yields this after each round, allowing inspection and decision.
 */
export interface RoundYield {
  /** Result of the completed round */
  roundResult: RoundResult
  /** Current cycle context */
  context: CycleContext
  /** Suggestions awaiting approval */
  pendingSuggestions: Suggestion[]
  /** Termination check result (use isCycleTerminated() to check if terminated) */
  terminationCheck: CycleTerminationResult
}

/** Decision from the caller after reviewing a round */
export interface RoundDecision {
  /** Action to take */
  action: 'continue' | 'stop' | 'rollback'
  /** Target round for rollback (required if action is 'rollback') */
  rollbackToRound?: number
  /** Suggestions approved by user (optional override) */
  approvedSuggestions?: Suggestion[]
}

/** Cost breakdown for a single round */
export interface RoundCost {
  /** Agent LLM cost in USD */
  agent: number
  /** Judge LLM cost in USD */
  judge: number
  /** Improver LLM cost in USD */
  improver: number
  /** Total cost in USD */
  total: number
}

/** Result of a single improvement round */
export interface RoundResult {
  /** Round number (1-indexed) */
  round: number
  /** When this round completed */
  completedAt: Date
  /** Full evaluation report */
  report: EvalReport<unknown, unknown>
  /** All suggestions generated by improver */
  suggestionsGenerated: Suggestion[]
  /** Suggestions that were approved/applied */
  suggestionsApproved: Suggestion[]
  /** Prompt snapshot at start of this round (for rollback) */
  promptSnapshot: SerializedPrompt
  /** Prompt version after applying suggestions */
  promptVersionAfter: string
  /** Cost breakdown for this round */
  cost: RoundCost
  /** Score change from previous round (null for first round) */
  scoreDelta: number | null
}

/**
 * Serialized prompt for JSON storage.
 * Note: buildUserPrompt cannot be serialized; use compileTemplate(userTemplate) to reconstruct.
 */
export interface SerializedPrompt {
  /** Prompt unique ID */
  id: string
  /** Version string (e.g., "1.0.0") */
  version: string
  /** System prompt */
  system: string
  /** User prompt template (Mustache format) */
  userTemplate: string
  /** Additional custom fields from AgentPrompt */
  customFields?: Record<string, unknown>
}

/** Serialized round result for JSON storage */
export interface SerializedRoundResult {
  /** Round number (1-indexed) */
  round: number
  /** Completion timestamp (ISO 8601) */
  completedAt: string
  /** Average score from this round */
  avgScore: number
  /** Number of passed tests */
  passed: number
  /** Number of failed tests */
  failed: number
  /** Total number of tests */
  totalTests: number
  /** All suggestions generated */
  suggestionsGenerated: Suggestion[]
  /** Suggestions that were approved/applied */
  suggestionsApproved: Suggestion[]
  /** Prompt snapshot at start of this round */
  promptSnapshot: SerializedPrompt
  /** Prompt version after applying suggestions */
  promptVersionAfter: string
  /** Cost breakdown */
  cost: RoundCost
  /** Score change from previous round */
  scoreDelta: number | null
}

/**
 * Improvement cycle history (JSON file schema v1.1.0).
 * Includes promptSnapshot per round for rollback support.
 */
export interface ImprovementHistory {
  /** Schema version for migration compatibility */
  schemaVersion: '1.1.0'
  /** Unique session identifier */
  sessionId: string
  /** Session start timestamp (ISO 8601) */
  startedAt: string
  /** Session completion timestamp (ISO 8601, if completed) */
  completedAt?: string
  /** Initial prompt before any improvements */
  initialPrompt: SerializedPrompt
  /** Current/latest prompt */
  currentPrompt: SerializedPrompt
  /** All completed rounds */
  rounds: SerializedRoundResult[]
  /** Reason for termination (if completed) */
  terminationReason?: string
  /** Total accumulated cost in USD */
  totalCost: number
}

/** History persistence configuration */
export interface HistoryConfig {
  /** Path to save history JSON */
  path: string
  /** Auto-save after each round (default: true) */
  autoSave?: boolean
}

/** Configuration for running an improvement cycle */
export interface ImprovementCycleConfig<TInput, TOutput> {
  /** Factory function to create agent with given prompt */
  createAgent: (prompt: AgentPrompt<TInput>) => EvalAgent<TInput, TOutput>
  /** Starting prompt for improvements */
  initialPrompt: AgentPrompt<TInput>
  /** Test cases to evaluate against */
  testCases: TestCase<TInput>[]
  /** Judge for evaluation */
  judge: Judge
  /** Improver for generating suggestions */
  improver: Improver
  /** Termination conditions (OR semantics) */
  terminateWhen: CycleTerminationCondition[]
  /** Optional configuration */
  options?: ImprovementCycleOptions
}

/** Optional configuration for improvement cycle */
export interface ImprovementCycleOptions {
  /** Options passed to eval suite run */
  runOptions?: { concurrency?: number; iterations?: number }
  /** How to bump version on each improvement */
  versionBump?: 'major' | 'minor' | 'patch'
  /** Pricing configuration for cost calculation */
  pricingConfig?: EvalPricingConfig
  /** History persistence settings */
  history?: HistoryConfig
  /** Description for agent (passed to judge) */
  agentDescription?: string
  /** Existing session to resume (preserves session ID and accumulated state) */
  session?: ImprovementSession
}

/** Final result of an improvement cycle */
export interface ImprovementCycleResult<TInput, TOutput> {
  /** Final improved prompt */
  finalPrompt: AgentPrompt<TInput>
  /** All completed rounds */
  rounds: RoundResult[]
  /** Reason for termination */
  terminationReason: string
  /** Total cost in USD */
  totalCost: number
  /** Saved history (if persistence was enabled) */
  history?: ImprovementHistory
}

export function isTargetScoreCondition(
  condition: CycleTerminationCondition
): condition is TargetScoreCondition {
  return condition.type === 'targetScore'
}

export function isMaxRoundsCondition(
  condition: CycleTerminationCondition
): condition is MaxRoundsCondition {
  return condition.type === 'maxRounds'
}

export function isNoImprovementCondition(
  condition: CycleTerminationCondition
): condition is NoImprovementCondition {
  return condition.type === 'noImprovement'
}

export function isMaxCostCondition(
  condition: CycleTerminationCondition
): condition is MaxCostCondition {
  return condition.type === 'maxCost'
}

export function isCustomCycleCondition(
  condition: CycleTerminationCondition
): condition is CustomCycleCondition {
  return condition.type === 'custom'
}

export function isCycleTerminated(
  result: CycleTerminationResult
): result is CycleTerminatedResult {
  return result.terminated === true
}
